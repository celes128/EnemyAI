#define NOMINMAX
#include "Table.h"

#include <algorithm>
#include <iostream>
#include <cassert>

#include "wincons.h"

static size_t num_columns_from_rows(const std::vector<TableRow> &rows)
{
	size_t nCols = 0;
	for (auto &row : rows) {
		nCols = std::max(nCols, row.NumColumns());
	}
	return nCols;
}

Table::Table(
	const TableLayoutInfo &layout,
	const std::vector<TableRow> &rows
)
	:
	m_layout(layout),
	m_rows(rows)
{	
	compute_column_infos();
	
	compute_frame_width();

	cache_graphics_strings();
}

void Table::Print() const
{
	if (empty()) {
		return;
	}

	/*
		Example of the output generated by this print function:

		-----------------------------------------------------   <---  Top horizontal bar
		|    <entry>   |      <entry>     |     <entry>     |
		-----------------------------------------------------	<---|
		|    <entry>   |      <entry>     |     <entry>     |       |
		-----------------------------------------------------	<---| Optional bars
		|    <entry>   |      <entry>     |     <entry>     |       |
		-----------------------------------------------------	<---|
	*/

	// Top horizontal bar
	println_horiz_bar();	

	for (size_t r = 0; r < num_rows(); r++) {
		println_row(r);

		// The printing of the other horizontal bars is decided
		// by the row. (flag printHorizBarBelow in the TableRow struct)
		optional_println_horiz_bar(r);
	}
}


// -----------------------------
// CATEGORY: constructor utils
// -----------------------------


void Table::compute_column_infos()
{
	auto nCols = num_columns_from_rows(m_rows);

	m_columnInfos.reserve(nCols);

	for (size_t c = 0; c < nCols; c++) {
		auto w = determine_column_width(c);

		TableColumnInfo info{ w };

		m_columnInfos.push_back(info);
	}
}

int Table::determine_column_width(size_t c)
{
	auto w = largest_text_width_in_column(c);

	return m_layout.colLeftPad + w + m_layout.colRightPad;
}

int Table::largest_text_width_in_column(size_t c)
{
	int w = 0;

	for (size_t r = 0; r < num_rows(); r++) {
		const auto &row = m_rows[r];

		if (row.InvalidColumnIndex(c)) {
			continue;
		}

		w = std::max(w, static_cast<int>(row.entries[c].text.size()));
	}

	return w;
}

void Table::compute_frame_width()
{
	m_frameWidth = 0;
	for (const auto &info : m_columnInfos) {
		m_frameWidth += info.width + 1;// + 1 for the vertical separation character '|'
	}
	++m_frameWidth;// + 1 for the vertical separation character '|'
}

void Table::cache_graphics_strings()
{
	m_horizBar = std::string(m_frameWidth, '-');

	m_colLeftPadStr = std::string(m_layout.colLeftPad, ' ');
	m_colRightPadStr = std::string(m_layout.colRightPad, ' ');
}


// ------------------------
// CATEGORY: print utils
// ------------------------

void Table::println_row(size_t r) const
{
	/*
		Example of the output generated by this print function:

		|    <entry>   |      <entry>     |     <entry>     |
	*/

	print_entry_vert_bar();
	for (size_t c = 0; c < num_columns(); c++) {
		print_entry(c, r);

		print_entry_vert_bar();
	}
	println();
}

void Table::println_horiz_bar() const
{
	std::cout << m_horizBar << std::endl;
}

void Table::optional_println_horiz_bar(size_t r) const
{
	if (m_rows[r].printHorizBarBelow) {
		println_horiz_bar();
	}
}

void Table::print_entry_vert_bar() const
{
	std::cout << "|";
}

void Table::print_entry(size_t c, size_t r) const
{
	const auto &row = m_rows[r];

	if (row.ValidColumnIndex(c)) {
		// Column left padding
		std::cout << m_colLeftPadStr;

		// Center the entry text
		const int kNumBlanks = m_columnInfos[c].width - (m_layout.colLeftPad + m_layout.colRightPad + row.entries[c].text.size());
		assert(kNumBlanks >= 0);

		// Left whitespaces
		std::cout << std::string(kNumBlanks / 2, ' ');

		// Entry text
		const auto &e = row.entries[c];
		if (e.ignoreTextColor) {
			std::cout << e.text;
		}
		else {
			WinCons::color_printf(e.textColor, WinCons::DO_NOT_INTENSIFY, "%s", e.text.c_str());
		}

		// Right whitespaces
		std::cout << std::string(kNumBlanks - kNumBlanks / 2, ' ');

		// Column right padding
		std::cout << m_colRightPadStr;
	}
	else {
		// Print an empty entry
		std::cout << std::string(m_columnInfos[c].width, ' ');
	}
}

void Table::println() const
{
	std::cout << std::endl;
}